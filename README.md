# Klaytn-smart-contract-dapp
한양대 X GroundX 강의 정리

klaytn기반의 스마트컨트랙트 &amp; 탈중앙화앱








## 블록체인이란? 
정보를 블록이라고 하는 단위로 저장하여 저장된 블록들을 체인 형태로 묶은 저장기술

block_0 — block_1 —— block_2 ———  block_3 —— block_4


Rule
1. 하나의 데이터에서 오직 단 하나의 해시가 도출
2. 임의의 데이터 x, y가 있을 때

A . If x == y  then H(x) == H(y)
B. If x != y then H(x) != H(y)
C. If H(x) == H(y) then x == y
 
즉, 같은 함수라도 다른 데이터를 해시할 경우 결과값이 크게 다른 것을 확인할 수 있음

Sha-256 에서 256은 비트수를 나타낸다 (편의상 HEX로 나타냄)









## 블록높이, 블록생성주기(시간)

블록들은 이전 블록이 아래에 오고 최근 블록이 위로 오도록 정렬하면
블록이 생성됨에 따라 체인의 높이가 늘어난다.

블록의 순서는 그 블록이 위치한 ‘높이’( block height)라 부른다.
첫번째 블록은 편의상 높이를 0이라 한다.


어떤 한 블록이 있을 때 그 블록위에 다른 블록을 생성하기까지 걸리는 시간을 블록생성시간이라
하고 블록생성시간이 비교적 일정한 경우 블록생성 주기란 표현을 사용한다.

비트코인의 블록생성주기 : 10분 
이더리움의 블록생성 주기 : 15초 ( 일정하지 않음)
클레이튼의 블록생성 주기 ? 1초 - 서비스에 적합한 블록체인










## 블록체인 네트워크 (peer - 2- peer) , 노드

- 블록체인은 한명 이상의 참여자가 있는 네트워크에서 관리한다.
- 네트워크 참여자 전원은 모든 블록을 동일한 순서로 저장하여 모두 같은 블록체인을 유지한다.










## 합의 ( Consensus )

-자격이 있는 참여자는 블록을 제안(propose)할 수 있다
-블록 제안 자격은 네트워크마다 상이 (e.g., PoW : 작업증명)
- 노드들은 제안자가 올바른 자격을 취득했는지, 제안된 블록이 올바른 검증 뒤 블록을 자신의 체인에 추가

- 정족수 또는 정해진 기준을 만족하는 수의 노드가 블록을 자신의 체인에 추가하면 합의가 이뤄졌다고 판단

￼

정리 
- 블록체인은 한명 이상의 참여자가 있는 네트워크에서 관리한다
- 네트워크 참여자 전원은 모든 블록을 동일한 순서로 저장하여 모두 같은 블록체인을 유지한다.
- 자격이 잇는 참여자는 블록을 제안할 수 있다 (블록 제안 자격은 네트워크마다 상이하다)
- 블록이 체인에 추가된다는 것은 참여자들이 새 블록을 자신의 체인에 추가했다는 것을 의미한다
따라서 새로운 블록이 체인에 추가되려면 네트워크의 *합의가 필요하다. (합의 방법은 네트워크마다 상이)

*’합의'라고 부르는 이유 : 어느 한 주체가 단독으로 결정하는 구조가 아닌, 여러 참여자가 합의를 통해 결정하기 때문에 블록체인은 탈중앙화되어 있다고 표현한다.

- 참여자 전원은 이전 블록들을 저장하고 있으므로 새로운 블록의 무결성을 확인할 수 있다
- 새롭게 제안되는 블록은 참여자들이 검증 및 합의할 수 있는 상태여야 한다 (투명성)
- 한번 쓰여진 블록은 이전 합의를 번복할 수 잇지 않는 한 변경될 수 없다 (불변성)













## Public vs. Private

퍼블릭과 프라이빗의 구분은 블록체인에 다음을 수행할 수 있는지 확인하여 결정한다: 

- 누구든지 기록된 정보(블록)를 자유롭게 읽을 수 있는지 ?
- 명시적인 등록 또는 자격취득 없이 정보를 블록체인 네트워크에 기록할 수 있는지?

블록체인의 정보가 공개되어 있고 네트워크가 정한 기준(e.g., gas fee)에 따라 정보를 기록요청할 수 있다면
그 블록체인은 퍼블릭/공개형이라 한다.

Ex) 클레이튼

이와 반대로 정보가 공개되어 있지 않고 미리 자격을 득한 사용자만이 정보를 기록할 수 있다면
그 블록체인은 프라이빗/비공개형이라 한다.


Permissionless  vs. Permissioned

일반적으로 네트워크의 참여가 제한된 경우 ‘permissioned’, 그렇지 않은 경우 ‘permission less’라 정의
네트워크의 참ㅁ여의 정의

- (넓은 의미) 블록체인 P2P 네트워크에 참여
- (좁은 의미) 합의 과정의 참여

Public / Private의 개념이 정보의 접근성(Access)와 관련이 있다면
Permissionless/Permissioned는 정보의 제어(Control), 즉 무엇이 블록에 포함되는지를 결정하는 지에 더 밀접한 개념이다











## 암호

고전적인 암호: 카이사르 암호
암호화하려는 내용을 알파벳별로 일정한 거리(distance, d)만큼 밀어서 다른 알파벳으로 치환하는 기법.
암호를 풀거나 만들때 알아야 할 정보를 키(key)라고 한다. 위 예제에서 사용된 키는 d= 3.


대칭키암호/비대칭키암호

평문(Plain Text)이란 암호화되어 있지 않은 문자열을 의미한다
- 암호화는 평문을 암호로 만드는 것이다 (cipher, encrypt)
- 복호화는 암호를 평문으로 만드는 것이다(decipher, decrypt)

암호화에 사용한 키와 복호화에 사용한 키가 동일한 경우 대칭키암호로 분류하고,
암호화에 사용한 키와 복호화에 사용한 키가 다를 경우 비대칭키암호로 분류한다.


비대칭키암호 (공개키암호)

두 개의 키를 사용하여 암호화와 복호화를 실행
- 암호화에 사용되는 키 = 공개키(public key, pk)
- 복호화에 사용되는 키 = 비밀키(private key/ secret key)

비대칭키 암호의 목적: 
“누구든지 암호화할 수 있지만 비밀키를 아는 사람만 복호화할 수 있어야 한다”

- 공개키와 비밀키를 한쌍으로 묶어주는 아주 큰 숫자들
- 비밀키로부터 공개키를 도출하는 것은 쉬움
- 공개키로부터 비밀키를 찾는 건 매우 어려움









## 전자서명

비대칭키 암호화는 지정된 사람만 정보를 확인할 수 있도록 도와준다(privacy)
- Alice가 Bob에게 메시지를 보낼 때 PK를 사용
- Bob은 이 메시지가 Alice에게서 온 것인지 어떻게 확인할까? 

전자서명은 누가 정보를 보냈는지 알기 위해 사용(non-repudiation)
- 전자서명은 비대칭암호의 응용프로그램.
- 서명은 비밀키로만 생성가능.
- 공개키는 서명이 짝을 이루는 비밀키로 생성되었는지를 검증







블록체인과 공개키암호

- 블록체인은 암호학적 기법을 토대로 만들어진 기술
- Bitcoin은 네트워크 참여자 모두가 같은 ‘원장’을 공유함으로써 투명한 거래가 가능
-원장은 어느 주소에 BTC가 있는지 기록하지만, 그 주소가 누구에게 속하는지는 기록하지 않는다
- bitcoin은 공개키암호를 사용하여 명시적인 비밀교환과정 없이 btc의 소유권 증명을 실행



공개키 암호화를 사용한 소유권 증명

- 대부분의 블록체인 주속는 공개키로부터 도출된 값
  1) bitcoin : hash 160 of a public key where Hash 160 = RIPEMD160 + SHA256
  2)Ethereum: Rightmost 160bit of Keccak hash of a public key

- Bitcoin의 경우
 임의의 주소 X에 10비트코인이 있다고 가정할 때 Alice는 X에서 또다른 임의의 주소 Y로
5BTC를 전송하는 거래를 성사시키기 위해 X로 변환되는 공개키와 짝으 이루는 비밀키로 해당 거래를
서명할 수 있어야 한다.

- Ethereum의 경우
임의의 주소 X에 위치한 어카운트의 잔고에 10ETH가 있다고 가정할 때 Alice는 X에서 또
,., 생략










## 트랜잭션(Transaction , TX)
블록 정보의 단위


- 블록은 트랜잭션들을 일정한 순서로 정렬하여 저장하는 컨테이너
- 트랜잭션은 어카운트의 행동
- 트랜잭션의 순서는 중요; 
TX_1 -> TX_2와 TX_2 -> TX_1은 다름

- 블록체인 참여자들을은 블록을 검증할 때 트랜잭션들이 올바른 순서로 정렬되었는지 확인 후 합의









## pow / bft 비교

Pow 기반 합의의 한계
PoW기반 합의는 확률에 기반하기 때문에 경우에 따라 블록이 사라질 수 있으므로 완결성이 부재함
PoW 블록체인은 수학적으로 복잡한 퍼즐을 풀어 블록을 제안할 자격을 얻는 구조

만약 두 명의 서로 다른 참여자가 동시에 퍼즐을 풀어 두 개의 올바른 블록을 생성한다면 두 블록 중 하나는(eventually) 사라지게 됨

이 때문에 블록이 확률적 완결성을 갖기까지 일정 갯수 이상의 블록이 생성되기를 기다려야 함.


Confirmation  VS Finality

1)  Confirmation 란 트랜잭션이 블록에 포함된 이후 생성된 블록에 포함된 이후 생성된 블록의 숫자
 -> 임의의 트랜잭션 T가 포함된 블록의 높이가 100, 현재 블록 높이가 105라면 T의 confirmation 숫자는 6
-> Pow를 사용하는 블록체인들은 ( bitcoin) finality가 없기 때문에 confirmation 숫자가 중요


2) Finality란 블록의 완결성을 의미한다.
-> 합의를 통해 생성된 블록이 번복되지 않을 경우 완결성이 존재

 

Understanding Bitcoin’s 6 Confirmations Rule

 - 네트워크 시차로 인해 생성된 우연한 복수의 블록들 가운데 하나가 선택되는데 필요한 블록은 두 어개 정도 - 2~3 confirmations

-  퍼즐을 빠르게 풀 수 있는 악의적인 참여자(공격자)가 있을 경우 그 참여자의 해시능력(hash power)에 따라
필요한 confirmation 숫자가 달라짐

- bitcoin의 6 confirmation 법칙은 공격자가 전체 해시 능력의 약 25%를 가질 때를 가정한 숫자



BFT 기반 블록체인

BFT 기반 블록체인은 블록의 완결성이 보장됨
 - 네트워크가 동기화되어 있기 때문.
- 블록 생성이 PoW에 비해 빠르고 경제적

하지만 네트워크 동기화의 필요로 인해 참여자의 숫자가 제한됨
- 네트워크 참여자 구성이 고정되어 있어야 합의 가능
- 구성이 변경될 경우 모든 네트워크 참여자가 새로운 구성을 인지하기 까지 합의 불가능









## Klaytn BFT

Klaytn은 확장가능한 BFT를 사용

- N 개의 노드 가운데 S개의 부분 노드 집합을 확률적으로 선택 ( where N is large, and S is sufficiently small)
- 전체집합을 거버넌스 카운실 (Governance Council), 
- 부분집합의 커미티(Committee)로 정의
- 커미티 선택은 VRF*로 구해진 무작위값에 기반

- 매 블록마다 새 커미티를 뽑아 BFT를 진행
- 기존의 BFT에 비해 확장성을 크게 개선










## 블록체인의 상태 ( Blockchain State)

(어카운트 기반) 블록체인의 상태
블록체인은 트랜잭션( 트랜잭션에는 from — to가 있다)으로 변화하는 상태기계(State Machine)








## State machine(상태 기계)

블록체인은 초기 상태에서 변경사항을 적용하여 최종 상태로 변화하는 상태 기계
- 이전 블록의 최종 상태(final state)는 현재 블록의 초기 상태(initial state)
- gen block의 경우 임의의 초기값들이 설정되는데 이것이 gen block의 초기 상태이자 최종상태

(어카운트 기반) 블록체인의 상태
- TX는 어카운트를 생성하거나 변경
-항상 같은 결과를 보장하기위해 하나의 TX가 반영되는 과정에서 다른 TX의 개입은 제한됨








 
## ( Recall ) Ethereum 어카운트의 종류 

1) External Account : 사용자(end user)가 사용하는 어카운트(a.k.a. EOA)
2) Contract Account : 스마트 컨트랙트를 표현하는 어카운트

 Ethereum은 EOA(Externall Owned Accounts)와 스마트컨트랙트(smart contract)의 상태를 기록 및 유지한다
-  스마트 컨트랙트는 특정 주소에 존재하는 실행 가능한 프로그램
-  프로그램은 상태를 가지기 때문에 Ethereum / Klaytn 은
스마트 컨트랙트를 어카운트로 표현 

EOA(Externall Owned Accounts)는 블록에 기록되는 TX를 생성
- 블록에 기록되는 TX들은 명시적인 변경을 일으킴
(e.g , 토큰 전송, 스마트컨트랙트 배포/실행)

 





## 트랜잭션(TX)과 가스(Gas)

1. TX의 목적은 블록체인의 상태를 변경하는 것
 - TX는 보내는 사람(sender, from)과 받는 사람(recipient , to)이 지정되어 있으며 
 To가 누구인지에 따라 TX의 목적이 세분화

2. Gas: TX를 처리하는 데 발생하는 비용
- TX를 처리하는데 필요한 자원(computing power, storage)을 비용으로 전환한 것이 가스(gas)
- Sender는 TX의 처리를 위해 필요하 가스의 총량과 같은 가치의 플랫폼 토큰을 제공해야함
- 이때 지출되는 플랫폼 토큰을 가스비(gas fee)라 정의
- 가스비는 블록을 생성한 노드가 수집 








## 트랜잭션과 서명
1) 플랫폼은 Sender가 TX가 처리되는데 필요한 가스비를 가지고 있는지 확인한다.
- 가스비 확인은 구현에 따라 상이
- Ethereum/Klaytn은 노드가 TX를 수신함과 동시에 가스비 이상의 balance가 있는지 확인
- TX의 체결과 동시에 sender의 balance에서 가스비를 차감

2) TX는 Sender의 서명(v, r, s)이 필요
- 어카운트의 balance를 사용하기 때문에 
- 서명은 구현마다 상이

Ex) 
Ethereal:  서명 -> 공개키 도출 -> 어카운트 주소 도출 -> 어카운트 존재유무 확인
Klaytn : from주소 확인 -> 저장된 공개키 불러오기 -> 서명 직접 검증







트랜잭션 예시
{
	
	nonce: 1,
	gasPrice: ‘0x05d21dba00’,
	gas: ‘0x93e0’,
	from : ‘0xd0ea3e0eabaea095ea3ba231c043’,
	to: ‘0x5e47b195eeb11d72f5e1d27aebb6d341f’,
	value: 10,
	v,
	r,	
	s
}

Nonce: 어카운트가 몇 번째 트랜잭션을 보내는 건지 알려준다
From : 송신자의 주소
To: 수신자의 주소

+
v,  r ,s 는 전자서명이다!












## 스마트컨트랙트와 솔리디티

### Smart Contracts 란?
특정 주소에 배포되어 있는 TX로 실행 가능한 코드
- 스마트 컨트랙트 소스코드는 함수와 상태를 표현 ; 컨트랙트 소스코드는 블록체인에 저장
- 함수는 상태를 변경하는 함수, 상태를 변경하지 않는 함수로 분류
- 사용자 (end user, EOA owner)가 스마트 컨트랙트 함수를 실행하거나 상태를 읽을 때 주소가 필요






### 스마트 컨트랙트는 사용자가 실행
- 상태를 변경하는 함수를 실행하려면 그에 맞는 TX를 생성하여 블록에 추가 ( TX체결 = 함수의 실행)
- 상태를 변경하지 않는 함수, 상태를 읽는 행위는 TX가 필요없음(노드에서 실행)







### Solidity
- Ethereum/Klaytn에서 지원하는 스마트 컨트랙트 언어
- Clayton Solidity 버전 0.4.24, 0.5.6 을 지원
- 일반적인 프로그래밍 언어와 그 문법과 사용이 유사하나 몇가지 제약이 존재
- e.g, 포인터의 개념이 없기 때문에 recursive type의 선언이 불가능











### Contract = Code + Data

- solidity 컨트랙트는 코드(함수)와 데이터(상태)로 구성 : 코드는 함수!! 데이터는 상태!!
- solidity 함수는 코드 안에 변수로 선언된 상태(state)를 변경하거나 불러옴

Contract SimpleStorage{

	uint storedData;
	function set(uint x) public{
		storedData = x ;
	}

	function get() public view reutuns (uint){
		return storedData;
	}

}


Solidity 예제 - Coin 컨트랙트

// solidity로 간단한 포인트 시스템을 구현
// [Coin 컨트랙트]

// 컨트랙트 생성자가 관리하는 포인트 시스템 컨트랙트로 포인트 시스템 고유의 
// 주소공간(address space)를 가지며, 각 주소의 포인트 잔고를 기록한다.


// 컨트랙트 생성자는 사용자 주소(e.g. , 0xALICE)에 포인트를 부여할 수 있고
// 사용자는 다른 사용자에게 포인트를 전송할 수 있다. (e.g., 0xALIST -> 0xBOB, 10 Coins)

Contract Coin {

	// [omitted for brevity] 
}

